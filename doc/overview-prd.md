## 概要

一言で言うと、**「伝言ゲームの『耳打ち』の部分を『お絵描き』と『文章』で交互に行うゲーム」**です。

絵が上手いかどうかよりも、**「どうしてこうなった！？」という予想外の展開を楽しむパーティーゲーム**として非常に人気があります。

---

### 🎮 具体的なゲームの流れ
4人〜数人で遊ぶ場合、以下のような流れで進行します。

1.  **お題を決める（全員）**
    *   参加者全員が、最初の「文章（お題）」を書きます。（例：「バナナを食べるゴリラ」）
2.  **絵を描く（次の人へ）**
    *   回ってきた「文章」を見て、それを「絵」で表現します。
3.  **回答する（さらに次の人へ）**
    *   回ってきた「絵」を見て、それが何を描いているか予想して「文章」にします。
4.  **繰り返す**
    *   これを交互（文章→絵→文章→絵...）に繰り返し、最後の人が回答するまで続けます。
5.  **結果発表（一番盛り上がるところ！）**
    *   最初のお題が、最終的にどう変化したかを全員で鑑賞します。

### 🤣 ここが面白い！
*   **絵が下手な方が盛り上がる**
    *   画伯（絵が独特な人）がいると、途中で全く違う意味に解釈され、最終的にとんでもない文章に変わってしまうのが醍醐味です。
*   **「奇跡の正解」も嬉しい**
    *   無茶苦茶な絵なのに、なぜか正しく伝わった時の感動もあります。
*   **ボイスチャットとの相性が抜群**
    *   DiscordやLINE通話などを繋ぎながら、「なんだこれ！？」「わからん！」とリアクションしながら遊ぶのが一般的です。

### 📱 遊びやすさのポイント
*   **無料・インストール不要**
    *   PC、スマホ、タブレットのどれでも、Webブラウザ（ChromeやSafariなど）があればURLを開くだけで遊べます。
*   **会員登録なし**
    *   ニックネームを入力するだけですぐに参加できます。
*   **プレイ人数**
    *   4人〜30人まで遊べますが、**4人〜10人くらい**が一番テンポよく楽しめます。

### 💡 補足
通常のモード以外にも、「模写モード」や「アニメーションを作るモード」など、色々なルールの変種が用意されていますが、まずは**「ノーマル」**モードで遊ぶのがおすすめ。
ただお題を出されてそれの絵を描いて他の人がなんなのか当てるモードも実装したい。
お題のテーマを絞れるようにもしたい（アニメキャラ、生き物、場所、など）

---

## MVP計画書（初版）

### 1. 目的・ゴール
- 友人グループがボイスチャットしながら 10 分以内で 1 ラウンド遊べる「お題→絵→お題」伝言お絵描きの最小実装を公開する。
- PC/スマホのブラウザで URL を開くだけで参加でき、登録不要で遊べる状態を目指す。

### 2. ターゲット・利用シーン（MVP想定）
- 4〜10 人のライトユーザー／友人グループ。
- Discord/LINE 通話を併用しつつ、カジュアルに 1〜2 ラウンド遊ぶシチュエーション。

### 3. スコープ
- **含める**
    - ルーム作成・参加（ニックネームのみ）。
    - ノーマルモード: 「お題（テキスト）→絵→お題→絵…」を人数分繰り返し、結果をリプレイ表示。
    - シンプルなお題入力 or ランダムお題配布（カテゴリ選択は後述 P1）。
    - ブラウザお絵描きキャンバス（色/ペン太さ/消しゴム程度）。
    - 同期はターンごと（リアルタイム同時描画同期は非必須）。
- **含めない（後回し）**
    - 高機能ペイントツール（レイヤー、スタンプ、マスク）。
    - ボイスチャット内蔵。
    - ランク/アカウント/フレンド機能。
    - 追加モード（模写/アニメーション）。

### 4. ユーザーストーリー（MVP）
- U1: 発起人はブラウザでアクセスし、ニックネーム入力→ルームを作成→URL を共有する。
- U2: 参加者は URL を踏み、ニックネーム入力だけで入室する。
- U3: 全員準備完了後、各自が最初のお題を入力して提出する。
- U4: 配られたお題を見て制限時間内に絵を描き提出する。
- U5: 配られた絵を見て文章で回答する（交互に続く）。
- U6: 全ターン終了後、最初のお題からの変遷をスライドショーで閲覧し、共有して笑う。

### 5. ゲーム進行フロー（ノーマル）
1. ルーム作成/参加
2. 準備OK待機（全員揃う）
3. 初期お題入力フェーズ
4. 交互フェーズ（文章→絵→文章→絵…）人数分ターン
5. 結果発表（各チェーンのリプレイ）
6. 続けてもう 1 ラウンド or 退室

### 6. 機能要件（優先度）
- P0（必須）
    - ルーム作成/参加（URL ベース、ニックネーム入力のみ）。
    - プレイヤー一覧・準備状態表示。
    - お題入力フォームと提出。
    - 描画キャンバス（色数少なめ、筆圧不要、Undo/Redo 1 手程度）。
    - 絵/文章の提出とターン管理（1 人ずつ配布）。
    - 結果リプレイ（1 チェーンずつ順送り表示）。
- P1（MVP+）
    - お題カテゴリ選択（動物/食べ物/キャラ などのプリセット）。
    - ターン制限時間の調整 UI。
    - スマホ向けキャンバス最適化（2 本指パン/ズームオフ、UI 配置調整）。
- P2（拡張案）
    - カスタムスタンプ/背景色。
    - AI お題生成。
    - リアルタイム同時描画観戦。

### 7. 非機能要件（MVP基準）
- 対応ブラウザ: Chrome/Safari（最新 2 バージョン）、モバイル優先で検証。
- パフォーマンス: 1 ルーム最大 12 人 ※確定、1 ラウンド内でキャンバス画像は軽量 PNG/JPEG 送信（≤200KB 目安）。
- 可用性: シングルリージョンで十分。障害時は再入室で復帰できる簡易リジューム。
- ログ/監視: クラッシュログと最低限のアクセスログのみ。

### 8. 技術構成案（MVP想定）と採用理由
- フロント: TypeScript + React（Vite）+ Canvas API / Zustand
    - 理由: 実装速度と学習コストの低さ。Vite は開発/ビルドが高速。Zustand は軽量でグローバル状態をシンプルに管理でき、Redux ほどのボイラープレートが不要。
- サーバ: Node.js + Fastify + WebSocket（room scope）
    - 理由: JS/TS でフロントと共通言語、Fastify は Express より低オーバーヘッドで型サポートが良い。WS はターン更新や提出イベントのプッシュに必要。
- ストレージ: Redis or Upstash Redis（KV/TTL）でルーム・チェーンを短期保持、画像は S3 互換（Supabase Storage）に永続保存 ※確定
    - 理由: 低レイテンシの一時保管に向く。リプレイ用 GIF/画像を永続保存し、後から閲覧・共有可能にする。
- 認証/識別: ルーム内はニックネーム＋一時トークン（UUID）で十分。CSRF は不要（SPA + API same origin）。
- デプロイ: Vercel（フロント静的配信 + Edge/Serverless） + Render/Fly（WS 常駐サーバ）構成 ※確定
    - 理由: 迅速な公開と無料/低コスト枠。WS を安定させるためにサーバは常駐型に分離。
- モニタリング: Sentry（フロント/バック）、簡易アクセスログ。

### 8.1 アーキテクチャ方針
- クリーンアーキテクチャ寄りの「機能別スライス」+ 薄いドメイン層。
    - ドメイン: ルーム、プレイヤー、チェーン、エントリー、設定。
    - アプリケーション: ユースケース（ルーム作成、参加、提出、リプレイフェッチ）。
    - インフラ: WebSocket ハンドラ、HTTP API、永続化（Redis/S3）、通知。
    - プレゼンテーション: React のページ/コンポーネントと状態管理。
- DDD をフルでやるより、MVP では「用語と境界を揃える」ことを重視。複雑度が上がるまで集約はシンプルに保つ。

### 8.2 コード構成（例）
- frontend/
    - src/
        - app/ (ルーティング、レイアウト)
        - features/
            - room/ (入室、プレイヤー一覧、準備状態)
            - prompt/ (お題入力)
            - drawing/ (キャンバス UI)
            - turn/ (ターン進行、タイマー、提出)
            - replay/ (リプレイ表示)
        - shared/ (UIコンポーネント、hooks、lib、types)
- server/
    - src/
        - domain/ (entities: Room, Chain, Entry, Player, Settings)
        - application/ (usecases: createRoom, joinRoom, submitEntry, startRound, getReplay)
        - infra/
            - http/ (Fastify ルーター)
            - ws/ (イベントハンドラ: join_room, submit_entry, next_turn)
            - storage/ (redisRoomRepo, s3ImageRepo)
            - services/ (id generator, time)
        - interfaces/ (DTO, validation, mappers)
    - test/ (ユースケースの単体テスト)

### 8.3 データフロー（簡易）
- HTTP: ルーム作成、リプレイ取得。
- WS: 参加、準備状態更新、ターン配布、提出通知、ラウンド完了通知。
- ストレージ: Redis に Room/Chain/Entry を JSON で保持（TTL で掃除）、S3 に描画 PNG/JPEG。

### 9. データモデル（ラフ）
- Room { id, status, players[], roundNumber }
- Player { id, name, ready, connectionState }
- Chain { id, roomId, ownerPlayerId, entries[] }
- Entry { order, type: text|drawing, authorId, payload(text|imageUrl), submittedAt }
- Settings { roundTimeSec, drawingTimeSec: 90, guessTimeSec: 50, category(optional) } ※確定

### 10. マイルストーン（例: 2 週間）
- Week1
    - Day1-2: ルーム作成/参加 UI + サーバルーム管理（WS）。
    - Day3-4: お題入力→配布→提出のフロー。
    - Day5: キャンバス最小機能（色/太さ/消しゴム/提出）。
    - Day6: 文章↔絵のターン進行と提出保存。
    - Day7: 結果リプレイ画面（スライド表示）。
- Week2
    - Day1: スマホ UI 最適化とバグ潰し。
    - Day2: シンプルお題プリセット追加（P1）。
    - Day3: タイマーと制限時間設定 UI（P1）。
    - Day4: 軽負荷テスト（10 人想定）とログ整備。
    - Day5: デプロイとフィードバック反映。

### 11. テスト観点（MVP）
- ルーム: 作成/参加/再入室、満員時拒否。
- ターン: 全員が提出しないと次へ進まない、タイムアウト時は白紙/空文字で自動提出 ※確定。
- キャンバス: モバイルの描画遅延、Undo/Redo、提出データサイズ上限。
- リプレイ: 並び順の正しさ、画像/テキスト欠損なし。
- 通信: 接続断→再接続時の復帰（少なくとも再入室で復元）。

### 12. リスクと対応
- モバイル描画の体感遅延 → キャンバス解像度/ストローク圧縮を早期に検証。
- 画像サイズ肥大 → 解像度固定と提出時にクライアント側で圧縮。
- 同時接続のスパイク → ルーム上限とレートリミットを設定。
- 不適切なお題 → プリセット中心＋通報ボタンは将来追加。

### 13. ヒアリングしたい点
- 技術スタックの希望はありますか？（例: Next.js/Vite、バックエンド FaaS など）
- デプロイ先の制約はありますか？（例: Vercel/Render/Fly/Heroku）
- 画像保存を永続化したいですか？ それともセッション中のみ保持で十分ですか？
- ターン制限時間の初期値の希望（例: 90 秒/120 秒）。